# 4. vm 虚拟机源码解析

## stack.go 堆栈

1. vm 使用了 stack.go 里面的对象 Stack 来作为虚拟机的堆栈。

2. Stack，比较简单，就是用 1024 个 big.Int 的定长数组来作为堆栈的存储。

3. 构造

   ```go
   // stack is an object for basic stack operations. Items popped to the stack are
   // expected to be changed and modified. stack does not take care of adding newly
   // initialised objects.
   // stack 是一个用于基本堆栈操作的对象。
   // 弹出到堆栈的项目预计会被更改和修改。
   // stack 不负责添加新初始化的对象。
   type Stack struct {
   	data []*big.Int
   }
   
   func newstack() *Stack {
   	return &Stack{data: make([]*big.Int, 0, 1024)}
   }
   ```

4. push 操作 

   ```go
   // 追加到最末尾
   func (st *Stack) push(d *big.Int) {
   	// NOTE push limit (1024) is checked in baseCheck
   	//stackItem := new(big.Int).Set(d)
   	//st.data = append(st.data, stackItem)
   	st.data = append(st.data, d)
   }
   func (st *Stack) pushN(ds ...*big.Int) {
   	st.data = append(st.data, ds...)
   }
   ```

5. pop 操作

   ```go
   // 从最末尾取出。
   func (st *Stack) pop() (ret *big.Int) {
   	ret = st.data[len(st.data)-1]
   	st.data = st.data[:len(st.data)-1]
   	return
   }
   ```

6. swap 操作。交换元素的值

   ```go
   // 交换堆栈顶的元素和离栈顶 n 距离的元素的值
   func (st *Stack) swap(n int) {
   	st.data[st.len()-n], st.data[st.len()-1] = st.data[st.len()-1], st.data[st.len()-n]
   }
   ```

7. dup 操作 复制指定位置的值到堆顶

   ```go
   // 复制指定位置的值到堆顶
   func (st *Stack) dup(pool *intPool, n int) {
   	st.push(pool.get().Set(st.data[st.len()-n]))
   }
   ```

8. peek 操作。查看栈顶元素

   ```go
   // 查看栈顶元素
   func (st *Stack) peek() *big.Int {
   	return st.data[st.len()-1]
   }
   ```

9. Back 操作。查看指定位置的元素

   ```go
   // Back returns the n'th item in stack
   // 查看指定位置的元素
   func (st *Stack) Back(n int) *big.Int {
   	return st.data[st.len()-n-1]
   }
   ```

10. require 操作。保证堆栈元素的数量要大于等于 n

    ```go
    // 保证堆栈元素的数量要大于等于 n
    func (st *Stack) require(n int) error {
    	if st.len() < n {
    		return fmt.Errorf("stack underflow (%d <=> %d)", len(st.data), n)
    	}
    	return nil
    }
    ```

11. Print。打印栈

    ```go
    func (st *Stack) Print() {
    	fmt.Println("### stack ###")
    	if len(st.data) > 0 {
    		for i, val := range st.data {
    			fmt.Printf("%-3d  %v\n", i, val)
    		}
    	} else {
    		fmt.Println("-- empty --")
    	}
    	fmt.Println("#############")
    }
    ```

## memory.go 内存

1. memory 代表了虚拟机里面使用的内存对象。

2. 构造，memory 的存储就是 byte[]。还有一个 lastGasCost 的记录。

   ```go
   // Memory implements a simple memory model for the ethereum virtual machine.
   type Memory struct {
   	store       []byte
   	lastGasCost uint64
   }
   
   func NewMemory() *Memory {
   	return &Memory{}
   }
   ```

3. 使用首先需要使用 Resize 分配空间

   ```go
   // Resize resizes the memory to size
   func (m *Memory) Resize(size uint64) {
   	if uint64(m.Len()) < size {
   		m.store = append(m.store, make([]byte, size-uint64(m.Len()))...)
   	}
   }
   ```

4. 然后使用 Set 来设置值

   ```go
   // Set sets offset + size to value
   func (m *Memory) Set(offset, size uint64, value []byte) {
   	// length of store may never be less than offset + size.
   	// The store should be resized PRIOR to setting the memory
   	// store 的长度永远不能小于 offset + size。
   	// 应该在设置内存之前调整存储的大小
   	if size > uint64(len(m.store)) {
   		panic("INVALID memory: store empty")
   	}
   
   	// It's possible the offset is greater than 0 and size equals 0. This is because
   	// the calcMemSize (common.go) could potentially return 0 when size is zero (NO-OP)
   	// 有可能 offset 大于 0 并且 size 等于 0。这是因为
   	// 当 size 为零时，calcMemSize (common.go) 可能返回 0 (NO-OP)
   	if size > 0 {
   		copy(m.store[offset:offset+size], value)
   	}
   }
   ```

5. Get 来取值， 一个是获取拷贝，一个是获取指针

   ```go
   // Get returns offset + size as a new slice
   func (self *Memory) Get(offset, size int64) (cpy []byte) {
   	if size == 0 {
   		return nil
   	}
   
   	if len(self.store) > int(offset) {
   		cpy = make([]byte, size)
   		copy(cpy, self.store[offset:offset+size])
   
   		return
   	}
   
   	return
   }
   
   // GetPtr returns the offset + size
   func (self *Memory) GetPtr(offset, size int64) []byte {
   	if size == 0 {
   		return nil
   	}
   
   	if len(self.store) > int(offset) {
   		return self.store[offset : offset+size]
   	}
   
   	return nil
   }
   ```

## stack_table.go 一些额外的帮助函数

```go
func makeStackFunc(pop, push int) stackValidationFunc {
	return func(stack *Stack) error {
		if err := stack.require(pop); err != nil {
			return err
		}

		if stack.len()+push-pop > int(params.StackLimit) {
			return fmt.Errorf("stack limit reached %d (%d)", stack.len(), params.StackLimit)
		}
		return nil
	}
}

func makeDupStackFunc(n int) stackValidationFunc {
	return makeStackFunc(n, n+1)
}

func makeSwapStackFunc(n int) stackValidationFunc {
	return makeStackFunc(n, n)
}
```

## jump_table.go

1. jumptable，是一个 [256]operation 的数据结构. 每个下标对应了一种指令，使用 operation 来存储了指令对应的处理逻辑，gas 消耗，堆栈验证方法，memory 使用的大小等功能。

2. 数据结构 operation 存储了一条指令的所需要的函数

   ```go
   type operation struct {
   	// op is the operation function
   	// 执行函数
   	execute executionFunc
   	// gasCost is the gas function and returns the gas required for execution
   	// gas 消耗函数
   	gasCost gasFunc
   	// validateStack validates the stack (size) for the operation
   	// 堆栈大小验证函数
   	validateStack stackValidationFunc
   	// memorySize returns the memory size required for the operation
   	// 需要的内存大小
   	memorySize memorySizeFunc
   
   	// 表示操作是否停止进一步执行
   	halts   bool // indicates whether the operation should halt further execution
   	// 指示程序计数器是否不增加
   	jumps   bool // indicates whether the program counter should not increment
   	// 确定这是否是一个状态修改操作
   	writes  bool // determines whether this a state modifying operation
   	// 指示检索到的操作是否有效并且已知
   	valid   bool // indication whether the retrieved operation is valid and known
   	// 确定操作是否恢复状态（隐式停止）
   	reverts bool // determines whether the operation reverts state (implicitly halts)
   	// 确定操作是否设置了返回数据内容
   	returns bool // determines whether the operations sets the return data content
   }
   ```

3. 指令集，下面定义了三种指令集，针对三种不同的以太坊版本

   ```go
   var (
   	frontierInstructionSet  = NewFrontierInstructionSet()
   	homesteadInstructionSet = NewHomesteadInstructionSet()
   	byzantiumInstructionSet = NewByzantiumInstructionSet()
   )
   ```

4. NewByzantiumInstructionSet，拜占庭版本首先调用 NewHomesteadInstructionSet 创造了前一个版本的指令，然后增加自己特有的指令 STATICCALL，RETURNDATASIZE，RETURNDATACOPY，REVERT

   ```go
   // NewByzantiumInstructionSet returns the frontier, homestead and
   // byzantium instructions.
   func NewByzantiumInstructionSet() [256]operation {
   	// instructions that can be executed during the homestead phase.
   	instructionSet := NewHomesteadInstructionSet()
   	instructionSet[STATICCALL] = operation{
   		execute:       opStaticCall,
   		gasCost:       gasStaticCall,
   		validateStack: makeStackFunc(6, 1),
   		memorySize:    memoryStaticCall,
   		valid:         true,
   		returns:       true,
   	}
   	instructionSet[RETURNDATASIZE] = operation{
   		execute:       opReturnDataSize,
   		gasCost:       constGasFunc(GasQuickStep),
   		validateStack: makeStackFunc(0, 1),
   		valid:         true,
   	}
   	instructionSet[RETURNDATACOPY] = operation{
   		execute:       opReturnDataCopy,
   		gasCost:       gasReturnDataCopy,
   		validateStack: makeStackFunc(3, 0),
   		memorySize:    memoryReturnDataCopy,
   		valid:         true,
   	}
   	instructionSet[REVERT] = operation{
   		execute:       opRevert,
   		gasCost:       gasRevert,
   		validateStack: makeStackFunc(2, 0),
   		memorySize:    memoryRevert,
   		valid:         true,
   		reverts:       true,
   		returns:       true,
   	}
   	return instructionSet
   }
   ```

5. NewHomesteadInstructionSet

   ```go
   // NewHomesteadInstructionSet returns the frontier and homestead
   // instructions that can be executed during the homestead phase.
   func NewHomesteadInstructionSet() [256]operation {
   	instructionSet := NewFrontierInstructionSet()
   	instructionSet[DELEGATECALL] = operation{
   		execute:       opDelegateCall,
   		gasCost:       gasDelegateCall,
   		validateStack: makeStackFunc(6, 1),
   		memorySize:    memoryDelegateCall,
   		valid:         true,
   		returns:       true,
   	}
   	return instructionSet
   }
   ```

6. NewFrontierInstructionSet，定义了 130 个左右的指令

## instruction.go 

因为指令很多，所以不一一列出来，只列举几个例子。虽然组合起来的功能可以很复杂，但是单个指令来说，还是比较直观的。

```go
func opPc(pc *uint64, evm *EVM, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {
	stack.push(evm.interpreter.intPool.get().SetUint64(*pc))
	return nil, nil
}

func opMsize(pc *uint64, evm *EVM, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {
	stack.push(evm.interpreter.intPool.get().SetInt64(int64(memory.Len())))
	return nil, nil
}
```

## gas_table.go

gas_table 返回了各种指令消耗的 gas 的函数
这个函数的返回值基本上只有 errGasUintOverflow 整数溢出的错误。

```go
func gasBalance(gt params.GasTable, evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {
	return gt.Balance, nil
}

func gasExtCodeSize(gt params.GasTable, evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {
	return gt.ExtcodeSize, nil
}

func gasSLoad(gt params.GasTable, evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {
	return gt.SLoad, nil
}

func gasExp(gt params.GasTable, evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {
	expByteLen := uint64((stack.data[stack.len()-2].BitLen() + 7) / 8)

	var (
		gas      = expByteLen * gt.ExpByte // no overflow check required. Max is 256 * ExpByte gas
		overflow bool
	)
	if gas, overflow = math.SafeAdd(gas, GasSlowStep); overflow {
		return 0, errGasUintOverflow
	}
	return gas, nil
}
```

## interpreter.go  解释器

1. 数据结构

   ```go
   // Config are the configuration options for the Interpreter
   // Config 是解释器的配置选项
   type Config struct {
   	// Debug enabled debugging Interpreter options
   	// Debug 启用调试解释器选项
   	Debug bool
   	// EnableJit enabled the JIT VM
   	// EnableJit 启用 JIT VM
   	EnableJit bool
   	// ForceJit forces the JIT VM
   	ForceJit bool
   	// Tracer is the op code logger
   	Tracer Tracer
   	// NoRecursion disabled Interpreter call, callcode,
   	// delegate call and create.
   	NoRecursion bool
   	// Disable gas metering
   	DisableGasMetering bool
   	// Enable recording of SHA3/keccak preimages
   	EnablePreimageRecording bool
   	// JumpTable contains the EVM instruction table. This
   	// may be left uninitialised and will be set to the default
   	// table.
   	JumpTable [256]operation
   }
   
   // Interpreter is used to run Ethereum based contracts and will utilise the
   // passed evmironment to query external sources for state information.
   // The Interpreter will run the byte code VM or JIT VM based on the passed
   // configuration.
   // Interpreter 用于运行基于以太坊的合约，并将利用传递的 evmironment 查询外部源的状态信息。
   // Interpreter 将根据传递的配置运行字节码 VM 或 JIT VM。
   type Interpreter struct {
   	evm      *EVM
   	cfg      Config
   	// 标识了很多操作的 Gas 价格
   	gasTable params.GasTable
   	intPool  *intPool
   
   	readOnly   bool   // Whether to throw on stateful modifications
   	// 最后一个函数的返回值
   	returnData []byte // Last CALL's return data for subsequent reuse
   }
   ```

2. 构造函数

   ```go
   // NewInterpreter returns a new instance of the Interpreter.
   func NewInterpreter(evm *EVM, cfg Config) *Interpreter {
   	// We use the STOP instruction whether to see
   	// the jump table was initialised. If it was not
   	// we'll set the default jump table.
   	// 用一个 STOP 指令测试 JumpTable 是否已经被初始化了, 如果没有被初始化,那么设置为默认值
   	if !cfg.JumpTable[STOP].valid {
   		switch {
   		case evm.ChainConfig().IsByzantium(evm.BlockNumber):
   			cfg.JumpTable = byzantiumInstructionSet
   		case evm.ChainConfig().IsHomestead(evm.BlockNumber):
   			cfg.JumpTable = homesteadInstructionSet
   		default:
   			cfg.JumpTable = frontierInstructionSet
   		}
   	}
   
   	return &Interpreter{
   		evm:      evm,
   		cfg:      cfg,
   		gasTable: evm.ChainConfig().GasTable(evm.BlockNumber),
   		intPool:  newIntPool(),
   	}
   }
   ```

3. 解释器一共就两个方法 enforceRestrictions 方法和 Run 方法

   ```go
   func (in *Interpreter) enforceRestrictions(op OpCode, operation operation, stack *Stack) error {
   	if in.evm.chainRules.IsByzantium {
   		if in.readOnly {
   			// If the interpreter is operating in readonly mode, make sure no
   			// state-modifying operation is performed. The 3rd stack item
   			// for a call operation is the value. Transferring value from one
   			// account to the others means the state is modified and should also
   			// return with an error.
   			// 如果解释器在只读模式下运行，请确保不执行状态修改操作。
   			// 调用操作的第三个堆栈项是值。 将值从一个帐户转移到其他帐户意味着状态被修改，
   			// 并且还应返回错误。
   			if operation.writes || (op == CALL && stack.Back(2).BitLen() > 0) {
   				return errWriteProtection
   			}
   		}
   	}
   	return nil
   }
   
   // Run loops and evaluates the contract's code with the given input data and returns
   // the return byte-slice and an error if one occurred.
   // 用给定的输入参数循环执行合约的代码，并返回返回的字节片段，如果发生错误则返回错误。
   // It's important to note that any errors returned by the interpreter should be
   // considered a revert-and-consume-all-gas operation. No error specific checks
   // should be handled to reduce complexity and errors further down the in.
   // 重要的是要注意，解释器返回的任何错误都会消耗全部 gas。 为了减少复杂性,没有特别的错误处理流程。
   func (in *Interpreter) Run(snapshot int, contract *Contract, input []byte) (ret []byte, err error) {
   	// Increment the call depth which is restricted to 1024
   	in.evm.depth++
   	defer func() { in.evm.depth-- }()
   
   	// Reset the previous call's return data. It's unimportant to preserve the old buffer
   	// as every returning call will return new data anyway.
   	// 重置前一次调用的返回数据。 保留旧缓冲区并不重要，因为每次返回调用都会返回新数据。
   	in.returnData = nil
   
   	// Don't bother with the execution if there's no code.
   	if len(contract.Code) == 0 {
   		return nil, nil
   	}
   
   	codehash := contract.CodeHash // codehash is used when doing jump dest caching
   	if codehash == (common.Hash{}) {
   		codehash = crypto.Keccak256Hash(contract.Code)
   	}
   
   	var (
   		op    OpCode        // current opcode
   		mem   = NewMemory() // bound memory
   		stack = newstack()  // local stack
   		// For optimisation reason we're using uint64 as the program counter.
   		// It's theoretically possible to go above 2^64. The YP defines the PC
   		// to be uint256. Practically much less so feasible.
   		// 出于优化原因，我们使用 uint64 作为程序计数器。
   		// 理论上可以超过 2^64。 YP 定义了 PC
   		// 为 uint256。 实际上不太可行。
   		pc   = uint64(0) // program counter
   		cost uint64
   		// copies used by tracer
   		stackCopy = newstack() // stackCopy needed for Tracer since stack is mutated by 63/64 gas rule
   		pcCopy    uint64       // needed for the deferred Tracer
   		gasCopy   uint64       // for Tracer to log gas remaining before execution
   		logged    bool         // deferred Tracer should ignore already logged steps
   	)
   	contract.Input = input
   
   	defer func() {
   		if err != nil && !logged && in.cfg.Debug {
   			in.cfg.Tracer.CaptureState(in.evm, pcCopy, op, gasCopy, cost, mem, stackCopy, contract, in.evm.depth, err)
   		}
   	}()
   
   	// The Interpreter main run loop (contextual). This loop runs until either an
   	// explicit STOP, RETURN or SELFDESTRUCT is executed, an error occurred during
   	// the execution of one of the operations or until the done flag is set by the
   	// parent context.
   	// 解释器的主要循环， 直到遇到 STOP，RETURN，SELFDESTRUCT 指令被执行，
   	// 或者是遇到任意错误，或者说 done 标志被父 context 设置。
   	for atomic.LoadInt32(&in.evm.abort) == 0 {
   		// Get the memory location of pc
   		op = contract.GetOp(pc)
   
   		if in.cfg.Debug {
   			logged = false
   			pcCopy = pc
   			gasCopy = contract.Gas
   			stackCopy = newstack()
   			for _, val := range stack.data {
   				stackCopy.push(val)
   			}
   		}
   
   		// Get the operation from the jump table matching the opcode and validate the
   		// stack and make sure there enough stack items available to perform the operation
   		// 通过 JumpTable 拿到对应的 operation
   		operation := in.cfg.JumpTable[op]
   		// 检查指令是否非法
   		if !operation.valid {
   			return nil, fmt.Errorf("invalid opcode 0x%x", int(op))
   		}
   		// 检查是否有足够的堆栈空间。 包括入栈和出栈
   		if err := operation.validateStack(stack); err != nil {
   			return nil, err
   		}
   		// If the operation is valid, enforce and write restrictions
   		// 这里检查了只读模式下面不能执行 writes 指令
   		// staticCall 的情况下会设置为 readonly 模式
   		if err := in.enforceRestrictions(op, operation, stack); err != nil {
   			return nil, err
   		}
   
   		var memorySize uint64
   		// calculate the new memory size and expand the memory to fit
   		// the operation
   		// 计算内存使用量，需要收费
   		if operation.memorySize != nil {
   			memSize, overflow := bigUint64(operation.memorySize(stack))
   			if overflow {
   				return nil, errGasUintOverflow
   			}
   			// memory is expanded in words of 32 bytes. Gas
   			// is also calculated in words.
   			if memorySize, overflow = math.SafeMul(toWordSize(memSize), 32); overflow {
   				return nil, errGasUintOverflow
   			}
   		}
   		// 这个参数在本地模拟执行的时候比较有用，可以不消耗或者检查 GAS 执行交易并得到返回结果
   		if !in.cfg.DisableGasMetering {
   			// consume the gas and return an error if not enough gas is available.
   			// cost is explicitly set so that the capture state defer method cas get the proper cost
   			// 计算 gas 的 Cost 并使用，如果不够，就返回 OutOfGas 错误。
   			cost, err = operation.gasCost(in.gasTable, in.evm, contract, stack, mem, memorySize)
   			if err != nil || !contract.UseGas(cost) {
   				return nil, ErrOutOfGas
   			}
   		}
   		// 扩大内存范围
   		if memorySize > 0 {
   			mem.Resize(memorySize)
   		}
   
   		if in.cfg.Debug {
   			in.cfg.Tracer.CaptureState(in.evm, pc, op, gasCopy, cost, mem, stackCopy, contract, in.evm.depth, err)
   			logged = true
   		}
   
   		// execute the operation
   		res, err := operation.execute(&pc, in.evm, contract, mem, stack)
   		// verifyPool is a build flag. Pool verification makes sure the integrity
   		// of the integer pool by comparing values to a default value.
   		if verifyPool {
   			verifyIntegerPool(in.intPool)
   		}
   		// if the operation clears the return data (e.g. it has returning data)
   		// set the last return to the result of the operation.
   		// 如果有返回值，那么就设置返回值。 注意只有最后一个返回有效果。
   		if operation.returns {
   			in.returnData = res
   		}
   
   		switch {
   		case err != nil:
   			return nil, err
   		case operation.reverts:
   			return res, errExecutionReverted
   		case operation.halts:
   			return res, nil
   		case !operation.jumps:
   			pc++
   		}
   	}
   	return nil, nil
   }
   ```

## contract.go

1. contract 代表了以太坊 state database 里面的一个合约。包含了合约代码，调用参数。

2. 结构

   ```go
   // ContractRef is a reference to the contract's backing object
   // ContractRef 是对合约支持对象的引用
   type ContractRef interface {
   	Address() common.Address
   }
   
   // AccountRef implements ContractRef.
   // AccountRef 实现 ContractRef。
   // Account references are used during EVM initialisation and
   // it's primary use is to fetch addresses. Removing this object
   // proves difficult because of the cached jump destinations which
   // are fetched from the parent contract (i.e. the caller), which
   // is a ContractRef.
   // 在 EVM 初始化期间使用帐户引用，它的主要用途是获取地址。
   // 由于从父合约（即调用方）获取的缓存跳转目标是 ContractRef，因此删除此对象很困难。
   type AccountRef common.Address
   
   // Address casts AccountRef to a Address
   // Address 将 AccountRef 转换为Address
   func (ar AccountRef) Address() common.Address { return (common.Address)(ar) }
   
   // Contract represents an ethereum contract in the state database. It contains
   // the the contract code, calling arguments. Contract implements ContractRef
   // Contract 代表状态数据库中的以太坊合约。 它包含合约代码，调用参数。 Contract 实现 ContractRef
   type Contract struct {
   	// CallerAddress is the result of the caller which initialised this
   	// contract. However when the "call method" is delegated this value
   	// needs to be initialised to that of the caller's caller.
   	// CallerAddress 是初始化这个合约的人。 如果是 delegate，这个值被设置为调用者的调用者。
   	CallerAddress common.Address
   	caller        ContractRef
   	self          ContractRef
   	// JUMPDEST 指令的分析
   	jumpdests destinations // result of JUMPDEST analysis.
   	//  代码
   	Code     []byte
   	// 代码的 HASH
   	CodeHash common.Hash
   	// 代码地址
   	CodeAddr *common.Address
   	// 输入参数
   	Input    []byte
   	// 合约还有多少 Gas
   	Gas   uint64
   	value *big.Int
   	// 好像没有使用
   	Args []byte
   
   	DelegateCall bool
   }
   ```

3. 构造

   ```go
   // NewContract returns a new contract environment for the execution of EVM.
   // NewContract 返回一个新的合约环境来执行 EVM。
   func NewContract(caller ContractRef, object ContractRef, value *big.Int, gas uint64) *Contract {
   	c := &Contract{CallerAddress: caller.Address(), caller: caller, self: object, Args: nil}
   
   	if parent, ok := caller.(*Contract); ok {
   		// Reuse JUMPDEST analysis from parent context if available.
   		// 如果 caller 是一个合约，说明是合约调用了我们。 jumpdests 设置为 caller 的 jumpdests
   		c.jumpdests = parent.jumpdests
   	} else {
   		c.jumpdests = make(destinations)
   	}
   
   	// Gas should be a pointer so it can safely be reduced through the run
   	// This pointer will be off the state transition
   	c.Gas = gas
   	// ensures a value is set
   	c.value = value
   
   	return c
   }
   ```

4. AsDelegate 将合约设置为委托调用并返回当前合约（用于链式调用）

   ```go
   // AsDelegate sets the contract to be a delegate call and returns the current
   // contract (for chaining calls)
   func (c *Contract) AsDelegate() *Contract {
   	c.DelegateCall = true
   	// NOTE: caller must, at all times be a contract. It should never happen
   	// that caller is something other than a Contract.
   	parent := c.caller.(*Contract)
   	c.CallerAddress = parent.CallerAddress
   	c.value = parent.value
   
   	return c
   }
   ```

5. GetOp  用来获取下一跳指令

   ```go
   // GetOp returns the n'th element in the contract's byte array
   func (c *Contract) GetOp(n uint64) OpCode {
   	return OpCode(c.GetByte(n))
   }
   
   // GetByte returns the n'th byte in the contract's byte array
   func (c *Contract) GetByte(n uint64) byte {
   	if n < uint64(len(c.Code)) {
   		return c.Code[n]
   	}
   
   	return 0
   }
   
   // Caller returns the caller of the contract.
   //
   // Caller will recursively call caller when the contract is a delegate
   // call, including that of caller's caller.
   func (c *Contract) Caller() common.Address {
   	return c.CallerAddress
   }
   ```

6. UseGas 使用 Gas

   ```go
   // UseGas attempts the use gas and subtracts it and returns true on success
   func (c *Contract) UseGas(gas uint64) (ok bool) {
   	if c.Gas < gas {
   		return false
   	}
   	c.Gas -= gas
   	return true
   }
   
   // Address returns the contracts address
   func (c *Contract) Address() common.Address {
   	return c.self.Address()
   }
   
   // Value returns the contracts value (sent to it from it's caller)
   func (c *Contract) Value() *big.Int {
   	return c.value
   }
   ```

7. SetCode，SetCallCode 设置代码

   ```go
   // SetCode sets the code to the contract
   func (self *Contract) SetCode(hash common.Hash, code []byte) {
   	self.Code = code
   	self.CodeHash = hash
   }
   
   // SetCallCode sets the code of the contract and address of the backing data
   // object
   func (self *Contract) SetCallCode(addr *common.Address, hash common.Hash, code []byte) {
   	self.Code = code
   	self.CodeHash = hash
   	self.CodeAddr = addr
   }
   ```

## evm.go

1. 数据结构

   ```go
   // Context provides the EVM with auxiliary information. Once provided
   // it shouldn't be modified.
   // 上下文为 EVM 提供辅助信息。 一旦提供，不应该修改。
   type Context struct {
   	// CanTransfer returns whether the account contains
   	// sufficient ether to transfer the value
   	// CanTransfer 函数返回账户是否有足够的 ether 用来转账
   	CanTransfer CanTransferFunc
   	// Transfer transfers ether from one account to the other
   	// Transfer 用来从一个账户给另一个账户转账
   	Transfer TransferFunc
   	// GetHash returns the hash corresponding to n
   	// GetHash 用来返回入参 n 对应的 hash 值
   	GetHash GetHashFunc
   
   	// Message information
   	// 用来提供 Origin 的信息 sender 的地址
   	Origin   common.Address // Provides information for ORIGIN
   	// 用来提供 GasPrice 信息
   	GasPrice *big.Int       // Provides information for GASPRICE
   
   	// Block information
   	Coinbase    common.Address // Provides information for COINBASE
   	GasLimit    *big.Int       // Provides information for GASLIMIT
   	BlockNumber *big.Int       // Provides information for NUMBER
   	Time        *big.Int       // Provides information for TIME
   	Difficulty  *big.Int       // Provides information for DIFFICULTY
   }
   
   // EVM is the Ethereum Virtual Machine base object and provides
   // the necessary tools to run a contract on the given state with
   // the provided context. It should be noted that any error
   // generated through any of the calls should be considered a
   // revert-state-and-consume-all-gas operation, no checks on
   // specific errors should ever be performed. The interpreter makes
   // sure that any errors generated are to be considered faulty code.
   // The EVM should never be reused and is not thread safe.
   // EVM 是以太坊虚拟机基础对象，并提供必要的工具，以使用提供的上下文运行给定状态的合约。
   // 应该指出的是，任何调用产生的任何错误都应该被认为是一种回滚修改状态和消耗所有 GAS 操作，
   // 不应该执行对具体错误的检查。 解释器确保生成的任何错误都被认为是错误的代码。
   type EVM struct {
   	// Context provides auxiliary blockchain related information
   	Context
   	// StateDB gives access to the underlying state
   	StateDB StateDB
   	// Depth is the current call stack
   	// 当前的调用堆栈
   	depth int
   
   	// chainConfig contains information about the current chain
   	// 包含了当前的区块链的信息
   	chainConfig *params.ChainConfig
   	// chain rules contains the chain rules for the current epoch
   	chainRules params.Rules
   	// virtual machine configuration options used to initialise the
   	// evm.
   	vmConfig Config
   	// global (to this context) ethereum virtual machine
   	// used throughout the execution of the tx.
   	interpreter *Interpreter
   	// abort is used to abort the EVM calling operations
   	// NOTE: must be set atomically
   	abort int32
   }
   ```

2. 构造函数

   ```go
   // NewEVM retutrns a new EVM . The returned EVM is not thread safe and should
   // only ever be used *once*.
   func NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config) *EVM {
   	evm := &EVM{
   		Context:     ctx,
   		StateDB:     statedb,
   		vmConfig:    vmConfig,
   		chainConfig: chainConfig,
   		chainRules:  chainConfig.Rules(ctx.BlockNumber),
   	}
   
   	evm.interpreter = NewInterpreter(evm, vmConfig)
   	return evm
   }
   
   // Cancel cancels any running EVM operation. This may be called concurrently and
   // it's safe to be called multiple times.
   func (evm *EVM) Cancel() {
   	atomic.StoreInt32(&evm.abort, 1)
   }
   ```

3. 合约创建 Create 会创建一个新的合约

   ```go
   // Create creates a new contract using code as deployment code.
   func (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {
   
   	// Depth check execution. Fail if we're trying to execute above the
   	// limit.
   	if evm.depth > int(params.CallCreateDepth) {
   		return nil, common.Address{}, gas, ErrDepth
   	}
   	if !evm.CanTransfer(evm.StateDB, caller.Address(), value) {
   		return nil, common.Address{}, gas, ErrInsufficientBalance
   	}
   	// Ensure there's no existing contract already at the designated address
   	// 确保特定的地址没有合约存在
   	nonce := evm.StateDB.GetNonce(caller.Address())
   	evm.StateDB.SetNonce(caller.Address(), nonce+1)
   
   	contractAddr = crypto.CreateAddress(caller.Address(), nonce)
   	contractHash := evm.StateDB.GetCodeHash(contractAddr)
   	if evm.StateDB.GetNonce(contractAddr) != 0 || (contractHash != (common.Hash{}) && contractHash != emptyCodeHash) {
   		return nil, common.Address{}, 0, ErrContractAddressCollision
   	}
   	// Create a new account on the state
   	// 创建一个 StateDB 的快照，以便回滚
   	snapshot := evm.StateDB.Snapshot()
   	// 创建账户
   	evm.StateDB.CreateAccount(contractAddr)
   	if evm.ChainConfig().IsEIP158(evm.BlockNumber) {
   		// 设置 nonce
   		evm.StateDB.SetNonce(contractAddr, 1)
   	}
   	// 转账
   	evm.Transfer(evm.StateDB, caller.Address(), contractAddr, value)
   
   	// initialise a new contract and set the code that is to be used by the
   	// E The contract is a scoped evmironment for this execution context
   	// only.
   	contract := NewContract(caller, AccountRef(contractAddr), value, gas)
   	contract.SetCallCode(&contractAddr, crypto.Keccak256Hash(code), code)
   
   	if evm.vmConfig.NoRecursion && evm.depth > 0 {
   		return nil, contractAddr, gas, nil
   	}
   	ret, err = run(evm, snapshot, contract, nil)
   	// check whether the max code size has been exceeded
   	// 检查初始化生成的代码的长度不超过限制
   	maxCodeSizeExceeded := evm.ChainConfig().IsEIP158(evm.BlockNumber) && len(ret) > params.MaxCodeSize
   	// if the contract creation ran successfully and no errors were returned
   	// calculate the gas required to store the code. If the code could not
   	// be stored due to not enough gas set an error and let it be handled
   	// by the error checking condition below.
   	// 如果合约创建成功并且没有错误返回，则计算存储代码所需的 GAS。
   	// 如果由于没有足够的 GAS 而导致代码不能被存储设置错误，并通过下面的错误检查条件来处理。
   	if err == nil && !maxCodeSizeExceeded {
   		createDataGas := uint64(len(ret)) * params.CreateDataGas
   		if contract.UseGas(createDataGas) {
   			evm.StateDB.SetCode(contractAddr, ret)
   		} else {
   			err = ErrCodeStoreOutOfGas
   		}
   	}
   
   	// When an error was returned by the EVM or when setting the creation code
   	// above we revert to the snapshot and consume any gas remaining. Additionally
   	// when we're in homestead this also counts for code storage gas errors.
   	// 当错误返回我们回滚修改
   	if maxCodeSizeExceeded || (err != nil && (evm.ChainConfig().IsHomestead(evm.BlockNumber) || err != ErrCodeStoreOutOfGas)) {
   		evm.StateDB.RevertToSnapshot(snapshot)
   		if err != errExecutionReverted {
   			contract.UseGas(contract.Gas)
   		}
   	}
   	// Assign err if contract code size exceeds the max while the err is still empty.
   	if maxCodeSizeExceeded && err == nil {
   		err = errMaxCodeSizeExceeded
   	}
   	return ret, contractAddr, contract.Gas, err
   }
   ```

4. Call 方法，无论我们转账或者是执行合约代码都会调用到这里， 同时合约里面的 call 指令也会执行到这里

   ```go
   // Call executes the contract associated with the addr with the given input as
   // parameters. It also handles any necessary value transfer required and takes
   // the necessary steps to create accounts and reverses the state in case of an
   // execution error or failed value transfer.
   // Call 执行与给定的 input 作为参数与 addr 相关联的合约。
   // 它还处理所需的任何必要的转账操作，并采取必要的步骤来创建帐户
   // 并在任意错误的情况下回滚所做的操作。
   func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {
   	if evm.vmConfig.NoRecursion && evm.depth > 0 {
   		return nil, gas, nil
   	}
   
   	// Fail if we're trying to execute above the call depth limit
   	//  调用深度最多 1024
   	if evm.depth > int(params.CallCreateDepth) {
   		return nil, gas, ErrDepth
   	}
   	// Fail if we're trying to transfer more than the available balance
   	// 查看我们的账户是否有足够的金钱。
   	if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {
   		return nil, gas, ErrInsufficientBalance
   	}
   
   	var (
   		to       = AccountRef(addr)
   		snapshot = evm.StateDB.Snapshot()
   	)
   	if !evm.StateDB.Exist(addr) {
   		// 查看指定地址是否存在
   		// 如果地址不存在，查看是否是 native go 的合约， native go 的合约在
   		// contracts.go 文件里面
   		precompiles := PrecompiledContractsHomestead
   		if evm.ChainConfig().IsByzantium(evm.BlockNumber) {
   			precompiles = PrecompiledContractsByzantium
   		}
   		// 如果不是指定的合约地址， 并且 value 的值为 0 那么返回正常，而且这次调用没有消耗 Gas
   		if precompiles[addr] == nil && evm.ChainConfig().IsEIP158(evm.BlockNumber) && value.Sign() == 0 {
   			return nil, gas, nil
   		}
   		// 负责在本地状态创建 addr
   		evm.StateDB.CreateAccount(addr)
   	}
   	// 执行转账
   	evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)
   
   	// initialise a new contract and set the code that is to be used by the
   	// E The contract is a scoped environment for this execution context
   	// only.
   	contract := NewContract(caller, to, value, gas)
   	contract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))
   
   	ret, err = run(evm, snapshot, contract, input)
   	// When an error was returned by the EVM or when setting the creation code
   	// above we revert to the snapshot and consume any gas remaining. Additionally
   	// when we're in homestead this also counts for code storage gas errors.
   	if err != nil {
   		evm.StateDB.RevertToSnapshot(snapshot)
   		if err != errExecutionReverted {
   			// 如果是由 revert 指令触发的错误，因为 ICO 一般设置了人数限制或者资金限制
   			// 在大家抢购的时候很可能会触发这些限制条件，导致被抽走不少钱。这个时候
   			// 又不能设置比较低的 GasPrice 和 GasLimit。因为要速度快。
   			// 那么不会使用剩下的全部 Gas，而是只会使用代码执行的 Gas
   			// 不然会被抽走 GasLimit *GasPrice 的钱，那可不少。
   			contract.UseGas(contract.Gas)
   		}
   	}
   	return ret, contract.Gas, err
   }
   ```

5. 剩下的三个函数 CallCode, DelegateCall 和 StaticCall，这三个函数不能由外部调用，只能由 Opcode 触发

   1. CallCode

      ```go
      // CallCode executes the contract associated with the addr with the given input
      // as parameters. It also handles any necessary value transfer required and takes
      // the necessary steps to create accounts and reverses the state in case of an
      // execution error or failed value transfer.
      //
      // CallCode differs from Call in the sense that it executes the given address'
      // code with the caller as context.
      // CallCode 与 Call 不同的地方在于它使用 caller 的 context 来执行给定地址的代码
      func (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {
      	if evm.vmConfig.NoRecursion && evm.depth > 0 {
      		return nil, gas, nil
      	}
      
      	// Fail if we're trying to execute above the call depth limit
      	if evm.depth > int(params.CallCreateDepth) {
      		return nil, gas, ErrDepth
      	}
      	// Fail if we're trying to transfer more than the available balance
      	if !evm.CanTransfer(evm.StateDB, caller.Address(), value) {
      		return nil, gas, ErrInsufficientBalance
      	}
      
      	var (
      		snapshot = evm.StateDB.Snapshot()
      		// 这里是最不同的地方 to 的地址被修改为 caller 的地址了 而且没有转账的行为
      		to       = AccountRef(caller.Address())
      	)
      	// initialise a new contract and set the code that is to be used by the
      	// E The contract is a scoped evmironment for this execution context
      	// only.
      	contract := NewContract(caller, to, value, gas)
      	contract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))
      
      	ret, err = run(evm, snapshot, contract, input)
      	if err != nil {
      		evm.StateDB.RevertToSnapshot(snapshot)
      		if err != errExecutionReverted {
      			contract.UseGas(contract.Gas)
      		}
      	}
      	return ret, contract.Gas, err
      }
      ```

   2. DelegateCall

      ```go
      // DelegateCall executes the contract associated with the addr with the given input
      // as parameters. It reverses the state in case of an execution error.
      //
      // DelegateCall differs from CallCode in the sense that it executes the given address'
      // code with the caller as context and the caller is set to the caller of the caller.
      // DelegateCall 和 CallCode 不同的地方在于 caller 被设置为 caller 的 caller
      func (evm *EVM) DelegateCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {
      	if evm.vmConfig.NoRecursion && evm.depth > 0 {
      		return nil, gas, nil
      	}
      	// Fail if we're trying to execute above the call depth limit
      	if evm.depth > int(params.CallCreateDepth) {
      		return nil, gas, ErrDepth
      	}
      
      	var (
      		snapshot = evm.StateDB.Snapshot()
      		to       = AccountRef(caller.Address())
      	)
      
      	// Initialise a new contract and make initialise the delegate values
      	// 标识为 AsDelete()
      	contract := NewContract(caller, to, nil, gas).AsDelegate()
      	contract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))
      
      	ret, err = run(evm, snapshot, contract, input)
      	if err != nil {
      		evm.StateDB.RevertToSnapshot(snapshot)
      		if err != errExecutionReverted {
      			contract.UseGas(contract.Gas)
      		}
      	}
      	return ret, contract.Gas, err
      }
      ```

   3. StaticCall

      ```go
      // StaticCall executes the contract associated with the addr with the given input
      // as parameters while disallowing any modifications to the state during the call.
      // Opcodes that attempt to perform such modifications will result in exceptions
      // instead of performing the modifications.
      // StaticCall 不允许执行任何修改状态的操作
      func (evm *EVM) StaticCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {
      	if evm.vmConfig.NoRecursion && evm.depth > 0 {
      		return nil, gas, nil
      	}
      	// Fail if we're trying to execute above the call depth limit
      	if evm.depth > int(params.CallCreateDepth) {
      		return nil, gas, ErrDepth
      	}
      	// Make sure the readonly is only set if we aren't in readonly yet
      	// this makes also sure that the readonly flag isn't removed for
      	// child calls.
      	if !evm.interpreter.readOnly {
      		evm.interpreter.readOnly = true
      		defer func() { evm.interpreter.readOnly = false }()
      	}
      
      	var (
      		to       = AccountRef(addr)
      		snapshot = evm.StateDB.Snapshot()
      	)
      	// Initialise a new contract and set the code that is to be used by the
      	// EVM. The contract is a scoped environment for this execution context
      	// only.
      	contract := NewContract(caller, to, new(big.Int), gas)
      	contract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))
      
      	// When an error was returned by the EVM or when setting the creation code
      	// above we revert to the snapshot and consume any gas remaining. Additionally
      	// when we're in Homestead this also counts for code storage gas errors.
      	ret, err = run(evm, snapshot, contract, input)
      	if err != nil {
      		evm.StateDB.RevertToSnapshot(snapshot)
      		if err != errExecutionReverted {
      			contract.UseGas(contract.Gas)
      		}
      	}
      	return ret, contract.Gas, err
      }
      ```